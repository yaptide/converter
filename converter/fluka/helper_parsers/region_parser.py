import copy
from dataclasses import dataclass, field
from enum import Enum

from converter import solid_figures
from converter.fluka.helper_parsers.figure_parser import FlukaFigure, get_figure_name_by_uuid, parse_fluka_figure


class BoolOperation(Enum):
    """Enum representing boolean operations used in Fluka zones."""

    INTERSECTION = 1
    SUBTRACTION = 2


@dataclass(frozen=False)
class FlukaRegion:
    """Dataclass mapping for Fluka regions."""

    name: str = ""
    figures_operators: list[list[tuple[BoolOperation, str]]] = field(default_factory=lambda: [])


def parse_regions(zones_json: dict, figures: list[FlukaFigure]) -> (list[FlukaRegion], list[FlukaFigure]):
    """
    Parse zones from JSON to Fluka regions.
    Returns list of regions and list of additional figures generated by parsing world zone.
    """
    # Naming is different in Fluka - Fluka zones consist of figures joined by subtractions and intersections
    # Fluka regions consist of zones joined by unions
    # uuid -> FlukRegion
    regions = {}
    zone_name = "region{}"
    for idx, zone in enumerate(zones_json["zones"]):
        regions[zone["uuid"]] = FlukaRegion(
            name=zone_name.format(idx),
            figures_operators=parse_csg_operations(zone["unionOperations"], figures),
        )
    if "worldZone" in zones_json:
        world_region, boundary_region, world_figure, world_boundary = parse_world_zone(zones_json, figures)
        regions[zones_json["worldZone"]["uuid"]] = world_region
        regions[zones_json["worldZone"]["uuid"] + "boundary"] = boundary_region

    return regions, [world_figure, world_boundary]


def parse_world_zone(zones_json: dict, figures: list[FlukaFigure]) -> (FlukaRegion, FlukaFigure, FlukaFigure):
    """
    Parse the world zone.
    Returns tuple consisting of world region, boundary region and the two figures of which they consist.
    """
    # Parse the world figure, then create boundary figure by expanding it
    # The boundary will have the black hole material
    world_zone_json = zones_json["worldZone"]
    world_figure = solid_figures.parse_figure(world_zone_json)
    world_boundary = copy.deepcopy(world_figure)
    world_boundary.expand(10)

    fluka_world_figure = parse_fluka_figure(world_figure)
    fluka_world_figure.name = "figworld"
    fluka_world_boundary = parse_fluka_figure(world_boundary)
    fluka_world_boundary.name = "figbound"

    # The boundary region consists of boundary figure with world figure subtracted
    boundary_region = FlukaRegion(
                name="boundary",
                figures_operators=[[(BoolOperation.INTERSECTION, fluka_world_boundary.name),
                                   (BoolOperation.SUBTRACTION, fluka_world_figure.name)]],
                )

    # Subtract all other figures from world region
    world_operations = [(BoolOperation.INTERSECTION, fluka_world_figure.name)]
    for figure in figures:
        world_operations.append((BoolOperation.SUBTRACTION, figure.name))

    # The world region consists of world figure with all other figures subtracted
    world_region = FlukaRegion(
                name="world",
                figures_operators=[world_operations],
                )

    return world_region, boundary_region, fluka_world_figure, fluka_world_boundary


def parse_csg_operations(operations: list[list[dict]], figures: list[FlukaFigure]) -> list[tuple[BoolOperation, str]]:
    """
    Parse dict of csg operations to a list of lists of tuples.
    Each tuple consists of a figure name and intersection or subtraction operation.
    Each list of tuples represents a Fluka zone.
    The list of lists represents a Fluka region, which consists of union of all zones.
    """
    zones_json = list(operations)
    region = []
    for zone in zones_json:
        operations_list = []
        for operation in zone:
            figure_name = get_figure_name_by_uuid(figures, operation['objectUuid'])
            if figure_name is None:
                raise ValueError(f"Cant find figure of uuid {operation['objectUuid']}")
            if operation["mode"] == "union" or operation["mode"] == "intersection":
                # In JSON received from frontend, first figure added to each zone is marked as a union operation.
                # However Fluka requires each zone to contain at least one figure marked with intersection.
                # This doesn't change the logic, as there is no way to add another union with a figure in the UI
                operations_list.append((BoolOperation.INTERSECTION, figure_name))
            elif operation["mode"] == "subtraction":
                operations_list.append((BoolOperation.SUBTRACTION, figure_name))
            else:
                raise ValueError(f"Unexpected CSG operation: {operation['mode']}")
        region.append(operations_list)

    return region