from dataclasses import dataclass, field
from enum import Enum

from converter import solid_figures
from converter.fluka.helper_parsers.figure_parser import FlukaFigure, get_figure_name_by_uuid, parse_fluka_figure

class BoolOperation(Enum):
    UNION = 1
    INTERSECTION = 2
    SUBTRACTION = 3

@dataclass
class FlukaZone:
    """Dataclass mapping for Fluka zones."""

    uuid: str = ""
    name: str = ""
    figures_operators: list[tuple[BoolOperation, str]] = field(default_factory=lambda: [])


def parse_zones(zones_json: dict, figures: list[FlukaFigure]) -> (list[FlukaZone], list[FlukaFigure]):
    """
    Parse zones from JSON.
    Returns list of zones and list of additional figures generated by parsing world zone.
    """
    zones = []
    zone_name = "zone{}"
    for idx, zone in enumerate(zones_json["zones"]):
        zones.append(
            FlukaZone(
                uuid=zone["uuid"],
                name=zone_name.format(idx),
                figures_operators=parse_csg_operations(zones_json["unionOperations"], figures),
            )
        )

    if "worldZone" in zones_json:
        world_zone, world_figure, world_boundary = parse_world_zone(zones_json)
        zones.append(world_zone)

    return zones, [world_figure, world_boundary]


def parse_world_zone(zones_json: dict) -> (FlukaZone, FlukaFigure, FlukaFigure):
    """
    Parse the world zone.
    Returns tuple consisting of world zone and the two figures of which it consists.
    """
    # Parse the world figure, then create boundary figure by expanding it
    # The boundary will have the black hole material
    world_zone_json = zones_json["zoneManager"]["worldZone"]
    world_figure = solid_figures.parse_figure(world_zone_json)
    world_boundary = world_figure.expand(1)

    fluka_world_figure = parse_fluka_figure(world_figure)
    fluka_world_figure.name = "figworld"
    fluka_world_boundary = parse_fluka_figure(world_boundary)
    fluka_world_boundary.name = "figbound"

    # The world zone consists of world boundary with subtracted world figure
    world_zone = FlukaZone(
                uuid=world_zone_json["uuid"],
                name="world",
                figures_operators=[(BoolOperation.INTERSECTION, fluka_world_boundary.name),
                                   (BoolOperation.SUBTRACTION, fluka_world_figure.name)],
                )
    
    return world_zone, fluka_world_figure, fluka_world_boundary
    

def parse_csg_operations(operations: list[list[dict]], figures: list[FlukaFigure]) -> list[tuple[BoolOperation, str]]:
    """
    Parse dict of csg operations to a list of sets. Sets contain a list of intersecting geometries.
    The list contains a union of geometries from sets.
    """
    list_of_operations = [item for ops in operations for item in ops]
    parsed_operations = []
    for operation in list_of_operations:
        figure_name = get_figure_name_by_uuid(figures, operation["objectUuid"])
        if figure_name is None:
            raise ValueError(f"Cant find figure of uuid {operation["objectUuid"]}")
        if operation["mode"] == "union":
            parsed_operations.append((BoolOperation.UNION, figure_name))
        elif operation["mode"] == "subtraction":
            parsed_operations.append((BoolOperation.SUBTRACTION, figure_name))
        elif operation["mode"] == "intersection":
            parsed_operations.append((BoolOperation.INTERSECTION, figure_name))
        else:
            raise ValueError(f"Unexpected CSG operation: {operation["mode"]}")

    return parsed_operations