from dataclasses import dataclass, field
from enum import Enum

from converter import solid_figures
from converter.fluka.helper_parsers.figure_parser import FlukaFigure, get_figure_name_by_uuid, parse_fluka_figure

class BoolOperation(Enum):
    INTERSECTION = 1
    SUBTRACTION = 2

@dataclass
class FlukaRegion:
    """Dataclass mapping for Fluka regions."""

    uuid: str = ""
    name: str = ""
    figures_operators: list[list[tuple[BoolOperation, str]]] = field(default_factory=lambda: [])


def parse_zones(zones_json: dict, figures: list[FlukaFigure]) -> (list[FlukaRegion], list[FlukaFigure]):
    """
    Parse zones from JSON to Fluka regions.
    Returns list of regions and list of additional figures generated by parsing world zone.
    """
    # Naming is different in Fluka - Fluka zones consist of figures joined by subtractions and intersections
    # Fluka regions consist of zones joined by unions
    regions = []
    zone_name = "region{}"
    for idx, zone in enumerate(zones_json["zones"]):
        regions.append(
            FlukaRegion(
                uuid=zone["uuid"],
                name=zone_name.format(idx),
                figures_operators=parse_csg_operations(zones_json["unionOperations"], figures),
            )
        )

    if "worldZone" in zones_json:
        world_zone, world_figure, world_boundary = parse_world_zone(zones_json)
        regions.append(world_zone)

    return regions, [world_figure, world_boundary]


def parse_world_zone(zones_json: dict) -> (FlukaRegion, FlukaFigure, FlukaFigure):
    """
    Parse the world zone.
    Returns tuple consisting of world zone and the two figures of which it consists.
    """
    # Parse the world figure, then create boundary figure by expanding it
    # The boundary will have the black hole material
    world_zone_json = zones_json["zoneManager"]["worldZone"]
    world_figure = solid_figures.parse_figure(world_zone_json)
    world_boundary = world_figure.expand(1)

    fluka_world_figure = parse_fluka_figure(world_figure)
    fluka_world_figure.name = "figworld"
    fluka_world_boundary = parse_fluka_figure(world_boundary)
    fluka_world_boundary.name = "figbound"

    # The world zone consists of world boundary with subtracted world figure
    world_region = FlukaRegion(
                uuid=world_zone_json["uuid"],
                name="world",
                figures_operators=[(BoolOperation.INTERSECTION, fluka_world_boundary.name),
                                   (BoolOperation.SUBTRACTION, fluka_world_figure.name)],
                )
    
    return world_region, fluka_world_figure, fluka_world_boundary
    

def parse_csg_operations(operations: list[list[dict]], figures: list[FlukaFigure]) -> list[tuple[BoolOperation, str]]:
    """
    Parse dict of csg operations to a list of lists of tuples.
    Each tuple consists of a figure name and intersection or subtraction operation.
    Each list of tuples represents a Fluka zone.
    The list of lists represents a Fluka region, which consists of union of all zones.
    """
    zones_json = [zone for zone in operations]
    region = []
    for zone in zones_json:
        operations_list = []
        for operation in zone:
            figure_name = get_figure_name_by_uuid(figures, operation["objectUuid"])
            if figure_name is None:
                raise ValueError(f"Cant find figure of uuid {operation["objectUuid"]}")
            if operation["mode"] == "union" | "intersection":
                # In JSON received from frontend, first figure added to each zone is marked as a union operation.
                # However Fluka requires each zone to contain at least one figure marked with intersection.
                # This doesn't change the logic, as there is no way to add another union with a figure in the UI
                operations_list.append((BoolOperation.INTERSECTION, figure_name))
            elif operation["mode"] == "subtraction":
                operations_list.append((BoolOperation.SUBTRACTION, figure_name))
            else:
                raise ValueError(f"Unexpected CSG operation: {operation["mode"]}")
        region.append(operations_list)

    return region